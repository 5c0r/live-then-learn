Obstacles while decomposing app -&gt; services	<ul> <li>Network latency</li> <li>Reduced availability due to synchronous communication</li> <li>Maintaining data consistency across services</li> <li>Obtaining a consistent view of the data</li> <li>God classes preventing decomposition</li></ul>
Remote Procedure invocation	"A client invokes a service using a synchronous, remote procedure invocation-based protocol, such as REST (<a href=""http://microservices.io/patterns/communication-style/messaging.html"">http://microservices.io/patterns/communication-style/messaging.html</a>)."
Fetching multiple resources in a single request	Falcor/GraphQL
Benefit of REST	- Simple + familiar<div>- Testable ( using curl/Postman)</div><div>- Request/response communication</div><div>- firewall friendly</div><div>- does not requires broker</div>
Drawback of REST	- Only support req/res communication<div>- Reduced availability. Both client and service must be running in order to buffer message (~nature of being broker-less)</div><div>- Client must know who is the service (~nature of being no service-discovery)</div><div>- Difficult/not-possible to map multiple UPDATE operation to HTTP verbs</div>
gRPC benefits	- straightforward to design an API that has rich set of update operations<div>- efficient, compact IPC mechanism, especially when exchanging large messages</div><div>- Bidirectional streaming enable both RPI and messaging styles of communication</div><div>- Interoperability between client and services in wide range of language.</div>
gRPC drawbacks	- More work for JS clients to consume gRPC-based API then REST/JSON&nbsp;<div>- HTTP/2 support ?</div>
Self registration ptrn	A service instance register itself into the service registry
Client-side discovery	"Service client retrieves the list of avail services from registry and load balances across them<div><br></div><div>Ref:<a href=""http://microservices.io/patterns/client-side-discovery.html"">http://microservices.io/patterns/client-side-discovery.html</a>.</div>"
3rd party registration	"svc instances are automatically registered with the registrar by a 3rd-party<div><br></div><div><a href=""http://microservices.io/patterns/3rd-party-registration.html"">http://microservices.io/patterns/3rd-party-registration.html</a>.<br></div>"
Server-side discovery	"A client make request to a route, which is responsible for SD<div><br></div><div><a href=""http://microservices.io/patterns/server-side-discovery.html"">http://microservices.io/patterns/server-side-discovery.html</a>.<br></div>"
Messaging, brokerless architecture benefits	<ul> <li>Allows lighter network traffic and better latency, because messages go directly from the sender to the receiver, instead of             having to go from the sender to the message broker and from there to the receiver          </li> <li>Eliminates the possibility of the message broker being a performance bottleneck or a single point of failure</li> <li>Features less operational complexity, because there is no message broker to set up and maintain</li></ul>
Brokerless messaging drawback	"<ul> <li>Services need to know about each other’s locations and must therefore use one of the discovery mechanisms describer earlier             in <a href=""https://learning.oreilly.com/library/view/microservices-patterns/9781617294549/kindle_split_011.html#ch03lev2sec8"">section 3.2.4</a>.          </li> <li>It offers reduced availability, because both the sender and receiver of a message must be available while the message is being             exchanged.          </li> <li>Implementing mechanisms, such as guaranteed delivery, is more challenging.</li></ul><div>In fact, some of these drawbacks, such as reduced availability and the need for service discovery, are the same as when using          synchronous, response/response.<br></div>"
Broker-based messaging benefits	- Loose coupling<div>- Message buffering</div><div>- Flexible communication</div><div>- Explicit IPC</div>
Broker-based messaging drawback	- Potential performance bottleneck / SPOF<div>- Additional operation complexity</div>
Messaging handle duplicate msgs	- Write idempotent message handlers<div>- Track messages and discard duplicate</div>
Using DB as a MQ	"<img src=""03fig13_alt.jpg"">"
<b>Pattern: Transactional outbox</b>	"<div>Publish an event or message as part of a database transaction by saving it in an OUTBOX in the database. See <a href=""http://microservices.io/patterns/data/transactional-outbox.html"">http://microservices.io/patterns/data/transactional-outbox.html</a>.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div>"
<b>Pattern: Polling publisher</b>	"<div>Publish messages by polling the outbox in the database. See <a href=""http://microservices.io/patterns/data/polling-publisher.html"">http://microservices.io/patterns/data/polling-publisher.html</a>.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div>"
<b>Pattern: Transaction log tailing</b>	"<ul> <li><i><div>publish changes made to the database by tailing the transaction log. See <a href=""http://microservices.io/patterns/data/transaction-log-tailing.html"">http://microservices.io/patterns/data/transaction-log-tailing.html</a>.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</div></i></li><li><i>Debezium</i> (<a href=""http://debezium.io"">http://debezium.io</a>)—An open source project that publishes database changes to the Apache Kafka message broker.</li><li><i>LinkedIn Databus</i> (<a href=""https://github.com/linkedin/databus"">https://github.com/linkedin/databus</a>)—An open source project that mines the Oracle transaction log and publishes the changes as events. LinkedIn uses Databus             to synchronize various derived data stores with the system of record.</li> <li><i>DynamoDB streams</i> (<a href=""http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html"">http://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html</a>)—DynamoDB  streams contain the time-ordered sequence of changes (creates, updates,  and deletes) made to the items in a DynamoDB             table in the last 24 hours. An application can read those  changes from the stream and, for example, publish them as events.          </li> <li><i>Eventuate Tram</i> (<a href=""https://github.com/eventuate-tram/eventuate-tram-core"">https://github.com/eventuate-tram/eventuate-tram-core</a>)—Your author’s very own open source transaction messaging library that uses MySQL binlog protocol, Postgres WAL, or polling             to read changes made to an OUTBOX table and publish them to Apache Kafka.&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</li></ul>"
